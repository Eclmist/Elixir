#
#    This file is part of Elixir, an open-source cross platform physically
#    based renderer.
#   
#    Copyright (c) 2019 Samuel Van Allen - All rights reserved.
#   
#    Elixir is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#   
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#   
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   

# Sets the minimum required CMake version. We need 3.6 for VS_STARTUP_PROJECT support
cmake_minimum_required (VERSION "3.14.4")

# Include the "ExternalProject" CMake module for building dependencies
include(ExternalProject)

# For using CMake to automatically update submodule
find_package(Git QUIET)

# We need the make command for building TSL. Find the binary, its one of these names
find_program(MAKE_EXE NAMES gmake nmake make mingw32-make mingw-make)

# =========================================================================== #
#                     PROJECT DEFINITIONS & PROPERTIES                        #
# =========================================================================== #

# Setup the name of the solution. This will change some of the directories naming convention
# generated by CMake. Ignore CXX in the second param since CMake supports C++ by default
project (Elixir)
set_property(DIRECTORY PROPERTY VS_STARTUP_PROJECT Elixir)

# Sets the C++ versions
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED true)
set(CMAKE_CXX_EXTENSIONS false)

# Group cmake defined targets into CMakePredefinedTargets
set(CMAKE_SUPPRESS_REGENERATION true)

# Set the project source directories. This is set when running the CMake GUI
set(EXR_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})

# Set the output of the elixir binary to /bin
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${EXR_SOURCE_DIR}/bin")

# Setting on project generation
set(EXR_USE_NAMESPACE "YES" CACHE BOOL "Enable generating Elixir namespace. This is enabled by default.") 
set(EXR_USE_FASTMATH "NO" CACHE BOOL "Enable fast math. May introduce arithmetic error. This is disabled by default")
set(EXR_USE_WHOLE_PROGRAMME_OPTIMIZATION "YES" CACHE BOOL "Enable whole programme optimizations. This is enabled by default.")
set(TSL_UPDATE_SUBMODULE_OVERRIDE "NO" CACHE BOOL "Blocks updating TSL submodule.")
set(TSL_UPDATE_DEP_OVERRIDE "NO" CACHE BOOL "Blocks download TSL dependencies. This is a hack explained below")
set(TSL_BUILD_OVERRIDE "NO" CACHE BOOL "Blocks building of TSL. This is a hack explained below")

# Options to choose configuration type
if (NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    message(STATUS "Setting build type to '{DEFAULT_BUILD_TYPE}' as none was specified.")
    set(CMAKE_BUILD_TYPE "${DEFAULT_BUILD_TYPE}" CACHE STRING "Choose the type of build." FORCE)
    # Set the possible values of build type for CMake GUI
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS "Debug" "Release")
endif ()


# =========================================================================== #
#                   SETUP THIRD PARTY/EXTERN DEPENDENCIES                     #
# =========================================================================== #

if (NOT TSL_UPDATE_SUBMODULE_OVERRIDE)
# Clone TSL submodule if it has not already been. This is executed during configure
    message(STATUS "Fetching TSL Submodule")
    execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
                    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                    RESULT_VARIABLE GIT_SUBMOD_RESULT)
    if(NOT GIT_SUBMOD_RESULT EQUAL "0")
        message(FATAL_ERROR "git submodule update --init failed with '${GIT_SUBMOD_RESULT}'.")
    endif()
endif()

# ================================== TSL ==================================== #

set(TSL_DIR ${EXR_SOURCE_DIR}/extern/tsl/)

if (WIN32)
    set(TSL_MAKE make.bat)
else()
    set(TSL_MAKE ${MAKE_EXE})
endif()

# TEMP - TSL's Update Dep will download TSL's dependencies every single time.
# Ideally, it should only download once and subsequent calls to 'make update_dep'
# should not be called again. If this were the case then the following can be
# combined into ExternalProject_Add, such that 'make update_dep' can be ran during
# build step. Since it is not the case, we will hack a call to 'make update_dep'\
# during CMake configure time.

if (NOT TSL_UPDATE_DEP_OVERRIDE)
    message(STATUS "Fetching TSL's Dependencies")
    execute_process(COMMAND ${TSL_MAKE} update_dep
                    WORKING_DIRECTORY ${TSL_DIR}
                    RESULT_VARIABLE UPDATE_DEP_RESULT)
    if(NOT UPDATE_DEP_RESULT EQUAL "0")
        message(FATAL_ERROR "make update_dep failed with '${UPDATE_DEP_RESULT}'.")
    endif()
endif()

if (NOT TSL_BUILD_OVERRIDE)
    message(STATUS "Build TSL")
    execute_process(COMMAND ${TSL_MAKE} install
                    WORKING_DIRECTORY ${TSL_DIR}
                    RESULT_VARIABLE BUILD_RESULT)
    if(NOT BUILD_RESULT EQUAL "0")
        message(FATAL_ERROR "make failed with '${BUILD_RESULT}'.")
    endif()
endif()

find_package(TSL REQUIRED CONFIG PATHS ${TSL_DIR})

# # output tsl library version
message(STATUS "Tiny Shading Langauge version: ${TSL_VERSION}")

include_directories("${TSL_INCLUDE_DIR}")
link_directories("${TSL_LIBRARY_DIR}")

if (WIN32)
    # Copy TSL dll to bin folder
    tsl_runtime_copy("${EXR_SOURCE_DIR}/bin/debug")
    tsl_runtime_copy("${EXR_SOURCE_DIR}/bin/release")
    tsl_runtime_copy("${EXR_SOURCE_DIR}/bin/relwithdebinfo")
    tsl_runtime_copy("${EXR_SOURCE_DIR}/bin/minsizerel")
endif()

# =========================================================================== #
#                            PLATFORM DEFINITIONS                             #
# =========================================================================== #

if (WIN32)
    set(EXR_PLATFORM_WIN true) 
    set(EXR_PLATFORM_MAC false) 
    set(EXR_PLATFORM_LINUX false) 
    set(EXR_PLATFORM_NAME "\"Windows\"") 
elseif (APPLE)
    set(EXR_PLATFORM_WIN false) 
    set(EXR_PLATFORM_MAC true) 
    set(EXR_PLATFORM_LINUX false) 
    set(EXR_PLATFORM_NAME "\"Mac OS\"") 
elseif (UNIX)
    set (EXR_PLATFORM_WIN false) 
    set (EXR_PLATFORM_MAC false) 
    set (EXR_PLATFORM_LINUX true) 
    set (EXR_PLATFORM_NAME "\"Linux\"") 
endif ()

# =========================================================================== #
#                           PLATFORM FEATURE QUERY                            #
# =========================================================================== #

# Check if aligned memory allocators available
include (CheckCXXSourceCompiles)

CHECK_CXX_SOURCE_COMPILES("
#include <malloc.h>
int main() { void * ptr = _aligned_malloc(1024, 32); }
" HAVE_ALIGNED_MALLOC)

CHECK_CXX_SOURCE_COMPILES("
#include <stdlib.h>
int main() {
    void *ptr;
    posix_memalign(&ptr, 32, 1024);
} " HAVE_POSIX_MEMALIGN)

CHECK_CXX_SOURCE_COMPILES("
#include <malloc.h>
int main() {
    void *ptr = memalign(32, 1024);
} " HAVE_MEMALIGN)

if (HAVE_ALIGNED_MALLOC)
    set(EXR_HAVE_ALIGNED_MALLOC true)
elseif (HAVE_POSIX_MEMALIGN)
    set(EXR_HAVE_POSIX_MEMALIGN true)
elseif (HAVE_MEMALIGN)
    set(EXR_HAVE_MEMALIGN true)
else ()
    message (SEND_ERROR "Unable to find a way to allocate aligned memory")
endif ()

# =========================================================================== #
#                      WRITE CONFIG INPUTS WITH VALUES                        #
# =========================================================================== #

# Send the variables to the source code header
configure_file (
    "${PROJECT_SOURCE_DIR}/src/system/config.h.in"
    "${PROJECT_SOURCE_DIR}/src/system/config.h"
)

# =========================================================================== #
#                        ADD SOURCE FILES TO PROJECT                          #
# =========================================================================== #

include_directories("${EXR_SOURCE_DIR}/src")
include_directories("${EXR_SOURCE_DIR}/extern")
include_directories("${EXR_SOURCE_DIR}/include")

# Find all source files and group them by directory
# I have no clue how this actually works, this macro was taken from SORT
macro (source_group_by_dir source_files)
    set(sgbd_cur_dir ${EXR_SOURCE_DIR}/src)
    foreach (sgbd_file ${${source_files}})
	    string(REGEX REPLACE ${sgbd_cur_dir}/\(.*\) \\1 sgbd_fpath ${sgbd_file})
	    string(REGEX REPLACE "\(.*\)/.*" \\1 sgbd_group_name ${sgbd_fpath})
	    string(COMPARE EQUAL ${sgbd_fpath} ${sgbd_group_name} sgbd_nogroup)
	    string(REPLACE "/" "\\" sgbd_group_name ${sgbd_group_name})
	    if (sgbd_nogroup)
	        set(sgbd_group_name "\\" )
	    endif (sgbd_nogroup)
	    source_group(${sgbd_group_name} FILES ${sgbd_file})
    endforeach (sgbd_file)
endmacro (source_group_by_dir)

file(GLOB_RECURSE project_headers src/*.h)
file(GLOB_RECURSE project_cpps src/*.cpp)
set(all_files ${project_headers} ${project_cpps})
source_group_by_dir(all_files)

# =========================================================================== #
#                          SET COMPILATION TARGETS                            #
# =========================================================================== #

add_executable (Elixir ${all_files})

# Set output name for different configs
set_target_properties (Elixir PROPERTIES RUNTIME_OUTPUT_NAME_RELEASE "elixir_r")
set_target_properties (Elixir PROPERTIES RUNTIME_OUTPUT_NAME_DEBUG "elixir_d")
set_target_properties (Elixir PROPERTIES RUNTIME_OUTPUT_NAME_RELWITHDEBINFO "elixir_rx")
set_target_properties (Elixir PROPERTIES RUNTIME_OUTPUT_NAME_MINSIZEREL "elixir_rm")

# =========================================================================== #
#                       SET COMPILATION/LINKER FLAGS                          #
# =========================================================================== #

if (CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    # Enable Whole Programme Optimization & Link Time Optimizations (/GL, /LTCG)
    if (EXR_USE_WHOLE_PROGRAMME_OPTIMIZATION )
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /GL")
        set_target_properties(Elixir PROPERTIES LINK_FLAGS_RELEASE "/LTCG")
    endif (EXR_USE_WHOLE_PROGRAMME_OPTIMIZATION)

    # Enables low precision fast math
    if (EXR_USE_FASTMATH)
        set_target_properties(Elixir PROPERTIES COMPILE_FLAGS "/fp:fast")
    endif (EXR_USE_FASTMATH)

    # Enable multi-thread compiling on Windows.
    include(ProcessorCount)
    ProcessorCount(N)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP${N}")

    # /MD needs to be set for TSL to work
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MD")

else ()
	set_source_files_properties(${all_files} PROPERTIES COMPILE_FLAGS -w)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")

    if(EXR_ENABLE_WHOLE_PROGRAMME_OPTIMIZATION)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -flto")
    endif()

    if(EXR_USE_FASTMATH)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -ffast-math")
    endif()
endif()

# =========================================================================== #
#                          LINK EXTERNAL LIBRARIES                            #
# =========================================================================== #

target_link_libraries(Elixir ${TSL_LIBS})

# Mark TSL as an Elixir dependency so that the above commands are ran first
# add_dependencies(Elixir TSL)

